export const memoryEngine = {
    /**
     * Scan events for new memory candidates.
     * In a production app, we would track which events we've already scanned,
     * but for MVP, we'll scan the recent history and avoid duplicates by checking existing memories.
     * @param {Array} events - Sorted events array (newest first)
     * @param {Array} existingMemories - Array of already generated memories
     */
    generateMemories: (events, existingMemories = []) => {
        if (!events || events.length === 0) return [];

        let newMemories = [];
        const sorted = [...events].sort((a, b) => new Date(a.startTime) - new Date(b.startTime)); // Oldest to newest for chronological scanning

        // 1. First Occurrences
        const firsts = new Set();
        sorted.forEach(ev => {
            if (!firsts.has(ev.type)) {
                firsts.add(ev.type);

                // Check if we already created a 'first' memory for this type
                const memoryId = `first_${ev.type}`;
                if (!existingMemories.find(m => m.id === memoryId)) {
                    let title = `First ${ev.type.charAt(0).toUpperCase() + ev.type.slice(1)}`;
                    let content = `A big moment: the very first ${ev.type}. Cherish these little firsts.`;
                    let mood = 'var(--color-primary-light)';

                    if (ev.type === 'feed') {
                        title = 'First Feed Logged';
                        content = 'The beginning of a beautiful nourishing journey.';
                        mood = 'var(--color-feed)';
                    } else if (ev.type === 'sleep') {
                        title = 'First Rest';
                        content = 'Sweet dreams. The first sleep session recorded.';
                        mood = 'var(--color-sleep)';
                    }

                    newMemories.push({
                        id: memoryId,
                        type: 'milestone',
                        title,
                        content,
                        timestamp: ev.startTime,
                        moodColor: mood,
                        relatedEventIds: [ev.id],
                        isAutoGenerated: true,
                        isFavorite: false
                    });
                }
            }
        });

        // 2. Longest Sleep Milestone (> 4 hours, and longer than previous best by 1h)
        let previousLongest = 0;
        sorted.forEach(ev => {
            if (ev.type === 'sleep' && ev.metadata?.duration) {
                const durationHours = ev.metadata.duration / (1000 * 60 * 60);
                if (durationHours > 4 && durationHours > previousLongest + 1) {
                    previousLongest = durationHours;
                    const memoryId = `sleep_record_${ev.id}`;

                    if (!existingMemories.find(m => m.id === memoryId)) {
                        newMemories.push({
                            id: memoryId,
                            type: 'milestone',
                            title: 'Sleep Record!',
                            content: `A beautiful stretch of sleepâ€”${durationHours.toFixed(1)} hours of rest. You're doing incredible.`,
                            timestamp: ev.endTime || ev.startTime,
                            moodColor: 'var(--color-sleep)',
                            relatedEventIds: [ev.id],
                            isAutoGenerated: true,
                            isFavorite: false
                        });
                    }
                }
            }
        });

        // 3. Caretaker Photo Moment
        sorted.forEach(ev => {
            if (ev.metadata?.mediaRef) {
                const memoryId = `photo_${ev.id}`;
                if (!existingMemories.find(m => m.id === memoryId)) {
                    newMemories.push({
                        id: memoryId,
                        type: 'moment',
                        title: 'A Captured Moment',
                        content: ev.metadata.notes || 'A sweet snapshot to remember this day.',
                        mediaRef: ev.metadata.mediaRef,
                        timestamp: ev.startTime,
                        moodColor: 'var(--color-surface)',
                        relatedEventIds: [ev.id],
                        isAutoGenerated: true,
                        isFavorite: false
                    });
                }
            }
        });

        return newMemories;
    }
};
